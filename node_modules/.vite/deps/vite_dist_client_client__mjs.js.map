{
  "version": 3,
  "sources": ["../../vite/src/client/env.ts", "../../vite/src/client/overlay.ts", "../../vite/src/client/client.ts"],
  "sourcesContent": ["declare const __MODE__: string\ndeclare const __DEFINES__: Record<string, any>\n\nconst context = (() => {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis\n  } else if (typeof self !== 'undefined') {\n    return self\n  } else if (typeof window !== 'undefined') {\n    return window\n  } else {\n    return Function('return this')()\n  }\n})()\n\n// assign defines\nconst defines = __DEFINES__\nObject.keys(defines).forEach((key) => {\n  const segments = key.split('.')\n  let target = context\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    if (i === segments.length - 1) {\n      target[segment] = defines[key]\n    } else {\n      target = target[segment] || (target[segment] = {})\n    }\n  }\n})\n", "import type { ErrorPayload } from 'types/hmrPayload'\n\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n  --monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: #d8d8d8;\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: #181818;\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"window\">\n  <pre class=\"message\"><span class=\"plugin\"></span><span class=\"message-body\"></span></pre>\n  <pre class=\"file\"></pre>\n  <pre class=\"frame\"></pre>\n  <pre class=\"stack\"></pre>\n  <div class=\"tip\">\n    Click outside or fix the code to dismiss.<br>\n    You can also disable this overlay by setting\n    <code>server.hmr.overlay</code> to <code>false</code> in <code>vite.config.js.</code>\n  </div>\n</div>\n`\n\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm\n\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {} as typeof globalThis.HTMLElement } = globalThis\nexport class ErrorOverlay extends HTMLElement {\n  root: ShadowRoot\n\n  constructor(err: ErrorPayload['err']) {\n    super()\n    this.root = this.attachShadow({ mode: 'open' })\n    this.root.innerHTML = template\n\n    codeframeRE.lastIndex = 0\n    const hasFrame = err.frame && codeframeRE.test(err.frame)\n    const message = hasFrame\n      ? err.message.replace(codeframeRE, '')\n      : err.message\n    if (err.plugin) {\n      this.text('.plugin', `[plugin:${err.plugin}] `)\n    }\n    this.text('.message-body', message.trim())\n\n    const [file] = (err.loc?.file || err.id || 'unknown file').split(`?`)\n    if (err.loc) {\n      this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, true)\n    } else if (err.id) {\n      this.text('.file', file)\n    }\n\n    if (hasFrame) {\n      this.text('.frame', err.frame!.trim())\n    }\n    this.text('.stack', err.stack, true)\n\n    this.root.querySelector('.window')!.addEventListener('click', (e) => {\n      e.stopPropagation()\n    })\n    this.addEventListener('click', () => {\n      this.close()\n    })\n  }\n\n  text(selector: string, text: string, linkFiles = false): void {\n    const el = this.root.querySelector(selector)!\n    if (!linkFiles) {\n      el.textContent = text\n    } else {\n      let curIndex = 0\n      let match: RegExpExecArray | null\n      while ((match = fileRE.exec(text))) {\n        const { 0: file, index } = match\n        if (index != null) {\n          const frag = text.slice(curIndex, index)\n          el.appendChild(document.createTextNode(frag))\n          const link = document.createElement('a')\n          link.textContent = file\n          link.className = 'file-link'\n          link.onclick = () => {\n            fetch('/__open-in-editor?file=' + encodeURIComponent(file))\n          }\n          el.appendChild(link)\n          curIndex += frag.length + file.length\n        }\n      }\n    }\n  }\n\n  close(): void {\n    this.parentNode?.removeChild(this)\n  }\n}\n\nexport const overlayId = 'vite-error-overlay'\nconst { customElements } = globalThis // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay)\n}\n", "import type { ErrorPayload, HMRPayload, Update } from 'types/hmrPayload'\nimport type { ModuleNamespace, ViteHotContext } from 'types/hot'\nimport type { InferCustomEventPayload } from 'types/customEvent'\nimport { ErrorOverlay, overlayId } from './overlay'\n// eslint-disable-next-line node/no-missing-import\nimport '@vite/env'\n\n// injected by the hmr plugin when served\ndeclare const __BASE__: string\ndeclare const __SERVER_HOST__: string\ndeclare const __HMR_PROTOCOL__: string | null\ndeclare const __HMR_HOSTNAME__: string | null\ndeclare const __HMR_PORT__: number | null\ndeclare const __HMR_DIRECT_TARGET__: string\ndeclare const __HMR_BASE__: string\ndeclare const __HMR_TIMEOUT__: number\ndeclare const __HMR_ENABLE_OVERLAY__: boolean\n\nconsole.debug('[vite] connecting...')\n\nconst importMetaUrl = new URL(import.meta.url)\n\n// use server configuration, then fallback to inference\nconst serverHost = __SERVER_HOST__\nconst socketProtocol =\n  __HMR_PROTOCOL__ || (location.protocol === 'https:' ? 'wss' : 'ws')\nconst hmrPort = __HMR_PORT__\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${\n  hmrPort || importMetaUrl.port\n}${__HMR_BASE__}`\nconst directSocketHost = __HMR_DIRECT_TARGET__\nconst base = __BASE__ || '/'\nconst messageBuffer: string[] = []\n\nlet socket: WebSocket\ntry {\n  let fallback: (() => void) | undefined\n  // only use fallback when port is inferred to prevent confusion\n  if (!hmrPort) {\n    fallback = () => {\n      // fallback to connecting directly to the hmr server\n      // for servers which does not support proxying websocket\n      socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n        const currentScriptHostURL = new URL(import.meta.url)\n        const currentScriptHost =\n          currentScriptHostURL.host +\n          currentScriptHostURL.pathname.replace(/@vite\\/client$/, '')\n        console.error(\n          '[vite] failed to connect to websocket.\\n' +\n            'your current setup:\\n' +\n            `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n            `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n            'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .'\n        )\n      })\n      socket.addEventListener(\n        'open',\n        () => {\n          console.info(\n            '[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.'\n          )\n        },\n        { once: true }\n      )\n    }\n  }\n\n  socket = setupWebSocket(socketProtocol, socketHost, fallback)\n} catch (error) {\n  console.error(`[vite] failed to connect to websocket (${error}). `)\n}\n\nfunction setupWebSocket(\n  protocol: string,\n  hostAndPath: string,\n  onCloseWithoutOpen?: () => void\n) {\n  const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr')\n  let isOpened = false\n\n  socket.addEventListener(\n    'open',\n    () => {\n      isOpened = true\n    },\n    { once: true }\n  )\n\n  // Listen for messages\n  socket.addEventListener('message', async ({ data }) => {\n    handleMessage(JSON.parse(data))\n  })\n\n  // ping server\n  socket.addEventListener('close', async ({ wasClean }) => {\n    if (wasClean) return\n\n    if (!isOpened && onCloseWithoutOpen) {\n      onCloseWithoutOpen()\n      return\n    }\n\n    console.log(`[vite] server connection lost. polling for restart...`)\n    await waitForSuccessfulPing(hostAndPath)\n    location.reload()\n  })\n\n  return socket\n}\n\nfunction warnFailedFetch(err: Error, path: string | string[]) {\n  if (!err.message.match('fetch')) {\n    console.error(err)\n  }\n  console.error(\n    `[hmr] Failed to reload ${path}. ` +\n      `This could be due to syntax errors or importing non-existent ` +\n      `modules. (see errors above)`\n  )\n}\n\nfunction cleanUrl(pathname: string): string {\n  const url = new URL(pathname, location.toString())\n  url.searchParams.delete('direct')\n  return url.pathname + url.search\n}\n\nlet isFirstUpdate = true\n\nasync function handleMessage(payload: HMRPayload) {\n  switch (payload.type) {\n    case 'connected':\n      console.debug(`[vite] connected.`)\n      sendMessageBuffer()\n      // proxy(nginx, docker) hmr ws maybe caused timeout,\n      // so send ping package let ws keep alive.\n      setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send('{\"type\":\"ping\"}')\n        }\n      }, __HMR_TIMEOUT__)\n      break\n    case 'update':\n      notifyListeners('vite:beforeUpdate', payload)\n      // if this is the first update and there's already an error overlay, it\n      // means the page opened with existing server compile error and the whole\n      // module script failed to load (since one of the nested imports is 500).\n      // in this case a normal update won't work and a full reload is needed.\n      if (isFirstUpdate && hasErrorOverlay()) {\n        window.location.reload()\n        return\n      } else {\n        clearErrorOverlay()\n        isFirstUpdate = false\n      }\n      payload.updates.forEach((update) => {\n        if (update.type === 'js-update') {\n          queueUpdate(fetchUpdate(update))\n        } else {\n          // css-update\n          // this is only sent when a css file referenced with <link> is updated\n          const { path, timestamp } = update\n          const searchUrl = cleanUrl(path)\n          // can't use querySelector with `[href*=]` here since the link may be\n          // using relative paths so we need to use link.href to grab the full\n          // URL for the include check.\n          const el = Array.from(\n            document.querySelectorAll<HTMLLinkElement>('link')\n          ).find((e) => cleanUrl(e.href).includes(searchUrl))\n          if (el) {\n            const newPath = `${base}${searchUrl.slice(1)}${\n              searchUrl.includes('?') ? '&' : '?'\n            }t=${timestamp}`\n\n            // rather than swapping the href on the existing tag, we will\n            // create a new link tag. Once the new stylesheet has loaded we\n            // will remove the existing link tag. This removes a Flash Of\n            // Unstyled Content that can occur when swapping out the tag href\n            // directly, as the new stylesheet has not yet been loaded.\n            const newLinkTag = el.cloneNode() as HTMLLinkElement\n            newLinkTag.href = new URL(newPath, el.href).href\n            const removeOldEl = () => el.remove()\n            newLinkTag.addEventListener('load', removeOldEl)\n            newLinkTag.addEventListener('error', removeOldEl)\n            el.after(newLinkTag)\n          }\n          console.log(`[vite] css hot updated: ${searchUrl}`)\n        }\n      })\n      break\n    case 'custom': {\n      notifyListeners(payload.event, payload.data)\n      break\n    }\n    case 'full-reload':\n      notifyListeners('vite:beforeFullReload', payload)\n      if (payload.path && payload.path.endsWith('.html')) {\n        // if html file is edited, only reload the page if the browser is\n        // currently on that page.\n        const pagePath = decodeURI(location.pathname)\n        const payloadPath = base + payload.path.slice(1)\n        if (\n          pagePath === payloadPath ||\n          payload.path === '/index.html' ||\n          (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)\n        ) {\n          location.reload()\n        }\n        return\n      } else {\n        location.reload()\n      }\n      break\n    case 'prune':\n      notifyListeners('vite:beforePrune', payload)\n      // After an HMR update, some modules are no longer imported on the page\n      // but they may have left behind side effects that need to be cleaned up\n      // (.e.g style injections)\n      // TODO Trigger their dispose callbacks.\n      payload.paths.forEach((path) => {\n        const fn = pruneMap.get(path)\n        if (fn) {\n          fn(dataMap.get(path))\n        }\n      })\n      break\n    case 'error': {\n      notifyListeners('vite:error', payload)\n      const err = payload.err\n      if (enableOverlay) {\n        createErrorOverlay(err)\n      } else {\n        console.error(\n          `[vite] Internal Server Error\\n${err.message}\\n${err.stack}`\n        )\n      }\n      break\n    }\n    default: {\n      const check: never = payload\n      return check\n    }\n  }\n}\n\nfunction notifyListeners<T extends string>(\n  event: T,\n  data: InferCustomEventPayload<T>\n): void\nfunction notifyListeners(event: string, data: any): void {\n  const cbs = customListenersMap.get(event)\n  if (cbs) {\n    cbs.forEach((cb) => cb(data))\n  }\n}\n\nconst enableOverlay = __HMR_ENABLE_OVERLAY__\n\nfunction createErrorOverlay(err: ErrorPayload['err']) {\n  if (!enableOverlay) return\n  clearErrorOverlay()\n  document.body.appendChild(new ErrorOverlay(err))\n}\n\nfunction clearErrorOverlay() {\n  document\n    .querySelectorAll(overlayId)\n    .forEach((n) => (n as ErrorOverlay).close())\n}\n\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length\n}\n\nlet pending = false\nlet queued: Promise<(() => void) | undefined>[] = []\n\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p: Promise<(() => void) | undefined>) {\n  queued.push(p)\n  if (!pending) {\n    pending = true\n    await Promise.resolve()\n    pending = false\n    const loading = [...queued]\n    queued = []\n    ;(await Promise.all(loading)).forEach((fn) => fn && fn())\n  }\n}\n\nasync function waitForSuccessfulPing(hostAndPath: string, ms = 1000) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      // A fetch on a websocket URL will return a successful promise with status 400,\n      // but will reject a networking error.\n      // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n      await fetch(`${location.protocol}//${hostAndPath}`, { mode: 'no-cors' })\n      break\n    } catch (e) {\n      // wait ms before attempting to ping again\n      await new Promise((resolve) => setTimeout(resolve, ms))\n    }\n  }\n}\n\n// https://wicg.github.io/construct-stylesheets\nconst supportsConstructedSheet = (() => {\n  // TODO: re-enable this try block once Chrome fixes the performance of\n  // rule insertion in really big stylesheets\n  // try {\n  //   new CSSStyleSheet()\n  //   return true\n  // } catch (e) {}\n  return false\n})()\n\nconst sheetsMap = new Map<\n  string,\n  HTMLStyleElement | CSSStyleSheet | undefined\n>()\n\nexport function updateStyle(id: string, content: string): void {\n  let style = sheetsMap.get(id)\n  if (supportsConstructedSheet && !content.includes('@import')) {\n    if (style && !(style instanceof CSSStyleSheet)) {\n      removeStyle(id)\n      style = undefined\n    }\n\n    if (!style) {\n      style = new CSSStyleSheet()\n      // @ts-expect-error: using experimental API\n      style.replaceSync(content)\n      // @ts-expect-error: using experimental API\n      document.adoptedStyleSheets = [...document.adoptedStyleSheets, style]\n    } else {\n      // @ts-expect-error: using experimental API\n      style.replaceSync(content)\n    }\n  } else {\n    if (style && !(style instanceof HTMLStyleElement)) {\n      removeStyle(id)\n      style = undefined\n    }\n\n    if (!style) {\n      style = document.createElement('style')\n      style.setAttribute('type', 'text/css')\n      style.innerHTML = content\n      document.head.appendChild(style)\n    } else {\n      style.innerHTML = content\n    }\n  }\n  sheetsMap.set(id, style)\n}\n\nexport function removeStyle(id: string): void {\n  const style = sheetsMap.get(id)\n  if (style) {\n    if (style instanceof CSSStyleSheet) {\n      // @ts-expect-error: using experimental API\n      document.adoptedStyleSheets = document.adoptedStyleSheets.filter(\n        (s: CSSStyleSheet) => s !== style\n      )\n    } else {\n      document.head.removeChild(style)\n    }\n    sheetsMap.delete(id)\n  }\n}\n\nasync function fetchUpdate({ path, acceptedPath, timestamp }: Update) {\n  const mod = hotModulesMap.get(path)\n  if (!mod) {\n    // In a code-splitting project,\n    // it is common that the hot-updating module is not loaded yet.\n    // https://github.com/vitejs/vite/issues/721\n    return\n  }\n\n  const moduleMap = new Map<string, ModuleNamespace>()\n  const isSelfUpdate = path === acceptedPath\n\n  // make sure we only import each dep once\n  const modulesToUpdate = new Set<string>()\n  if (isSelfUpdate) {\n    // self update - only update self\n    modulesToUpdate.add(path)\n  } else {\n    // dep update\n    for (const { deps } of mod.callbacks) {\n      deps.forEach((dep) => {\n        if (acceptedPath === dep) {\n          modulesToUpdate.add(dep)\n        }\n      })\n    }\n  }\n\n  // determine the qualified callbacks before we re-import the modules\n  const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => {\n    return deps.some((dep) => modulesToUpdate.has(dep))\n  })\n\n  await Promise.all(\n    Array.from(modulesToUpdate).map(async (dep) => {\n      const disposer = disposeMap.get(dep)\n      if (disposer) await disposer(dataMap.get(dep))\n      const [path, query] = dep.split(`?`)\n      try {\n        const newMod: ModuleNamespace = await import(\n          /* @vite-ignore */\n          base +\n            path.slice(1) +\n            `?import&t=${timestamp}${query ? `&${query}` : ''}`\n        )\n        moduleMap.set(dep, newMod)\n      } catch (e) {\n        warnFailedFetch(e, dep)\n      }\n    })\n  )\n\n  return () => {\n    for (const { deps, fn } of qualifiedCallbacks) {\n      fn(deps.map((dep) => moduleMap.get(dep)))\n    }\n    const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`\n    console.log(`[vite] hot updated: ${loggedPath}`)\n  }\n}\n\nfunction sendMessageBuffer() {\n  if (socket.readyState === 1) {\n    messageBuffer.forEach((msg) => socket.send(msg))\n    messageBuffer.length = 0\n  }\n}\n\ninterface HotModule {\n  id: string\n  callbacks: HotCallback[]\n}\n\ninterface HotCallback {\n  // the dependencies must be fetchable paths\n  deps: string[]\n  fn: (modules: Array<ModuleNamespace | undefined>) => void\n}\n\ntype CustomListenersMap = Map<string, ((data: any) => void)[]>\n\nconst hotModulesMap = new Map<string, HotModule>()\nconst disposeMap = new Map<string, (data: any) => void | Promise<void>>()\nconst pruneMap = new Map<string, (data: any) => void | Promise<void>>()\nconst dataMap = new Map<string, any>()\nconst customListenersMap: CustomListenersMap = new Map()\nconst ctxToListenersMap = new Map<string, CustomListenersMap>()\n\nexport function createHotContext(ownerPath: string): ViteHotContext {\n  if (!dataMap.has(ownerPath)) {\n    dataMap.set(ownerPath, {})\n  }\n\n  // when a file is hot updated, a new context is created\n  // clear its stale callbacks\n  const mod = hotModulesMap.get(ownerPath)\n  if (mod) {\n    mod.callbacks = []\n  }\n\n  // clear stale custom event listeners\n  const staleListeners = ctxToListenersMap.get(ownerPath)\n  if (staleListeners) {\n    for (const [event, staleFns] of staleListeners) {\n      const listeners = customListenersMap.get(event)\n      if (listeners) {\n        customListenersMap.set(\n          event,\n          listeners.filter((l) => !staleFns.includes(l))\n        )\n      }\n    }\n  }\n\n  const newListeners: CustomListenersMap = new Map()\n  ctxToListenersMap.set(ownerPath, newListeners)\n\n  function acceptDeps(deps: string[], callback: HotCallback['fn'] = () => {}) {\n    const mod: HotModule = hotModulesMap.get(ownerPath) || {\n      id: ownerPath,\n      callbacks: []\n    }\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    })\n    hotModulesMap.set(ownerPath, mod)\n  }\n\n  const hot: ViteHotContext = {\n    get data() {\n      return dataMap.get(ownerPath)\n    },\n\n    accept(deps?: any, callback?: any) {\n      if (typeof deps === 'function' || !deps) {\n        // self-accept: hot.accept(() => {})\n        acceptDeps([ownerPath], ([mod]) => deps && deps(mod))\n      } else if (typeof deps === 'string') {\n        // explicit deps\n        acceptDeps([deps], ([mod]) => callback && callback(mod))\n      } else if (Array.isArray(deps)) {\n        acceptDeps(deps, callback)\n      } else {\n        throw new Error(`invalid hot.accept() usage.`)\n      }\n    },\n\n    // export names (first arg) are irrelevant on the client side, they're\n    // extracted in the server for propagation\n    acceptExports(_: string | readonly string[], callback?: any) {\n      acceptDeps([ownerPath], callback && (([mod]) => callback(mod)))\n    },\n\n    dispose(cb) {\n      disposeMap.set(ownerPath, cb)\n    },\n\n    // @ts-expect-error untyped\n    prune(cb: (data: any) => void) {\n      pruneMap.set(ownerPath, cb)\n    },\n\n    // TODO\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    decline() {},\n\n    invalidate() {\n      // TODO should tell the server to re-perform hmr propagation\n      // from this module as root\n      location.reload()\n    },\n\n    // custom events\n    on(event, cb) {\n      const addToMap = (map: Map<string, any[]>) => {\n        const existing = map.get(event) || []\n        existing.push(cb)\n        map.set(event, existing)\n      }\n      addToMap(customListenersMap)\n      addToMap(newListeners)\n    },\n\n    send(event, data) {\n      messageBuffer.push(JSON.stringify({ type: 'custom', event, data }))\n      sendMessageBuffer()\n    }\n  }\n\n  return hot\n}\n\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nexport function injectQuery(url: string, queryToInject: string): string {\n  // skip urls that won't be handled by vite\n  if (!url.startsWith('.') && !url.startsWith('/')) {\n    return url\n  }\n\n  // can't use pathname from URL since it may be relative like ../\n  const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '')\n  const { search, hash } = new URL(url, 'http://vitejs.dev')\n\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${\n    hash || ''\n  }`\n}\n\nexport { ErrorOverlay }\n"],
  "mappings": ";;;AAGA,IAAM,WAAW,MAAK;AACpB,MAAI,OAAO,eAAe,aAAa;AACrC,WAAO;EACR,WAAU,OAAO,SAAS,aAAa;AACtC,WAAO;EACR,WAAU,OAAO,WAAW,aAAa;AACxC,WAAO;EACR,OAAM;AACL,WAAO,SAAS,aAAa,EAAC;EAC/B;AACH,GAAC;AAGD,IAAM,UAAU;AAChB,OAAO,KAAK,OAAO,EAAE,QAAQ,CAAC,QAAO;AACnC,QAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,UAAM,UAAU,SAAS;AACzB,QAAI,MAAM,SAAS,SAAS,GAAG;AAC7B,aAAO,WAAW,QAAQ;IAC3B,OAAM;AACL,eAAS,OAAO,aAAa,OAAO,WAAW,CAAA;IAChD;EACF;AACH,CAAC;;;AC1BD,IAAM,WAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgH1B,IAAM,SAAS;AACf,IAAM,cAAc;AAIpB,IAAM,EAAE,cAAc,MAAA;EAAyC,IAAK;AAC9D,IAAO,eAAP,cAA4B,YAAW;EAG3C,YAAY,KAAwB;;AAClC,UAAK;AACL,SAAK,OAAO,KAAK,aAAa,EAAE,MAAM,OAAM,CAAE;AAC9C,SAAK,KAAK,YAAY;AAEtB,gBAAY,YAAY;AACxB,UAAM,WAAW,IAAI,SAAS,YAAY,KAAK,IAAI,KAAK;AACxD,UAAM,UAAU,WACZ,IAAI,QAAQ,QAAQ,aAAa,EAAE,IACnC,IAAI;AACR,QAAI,IAAI,QAAQ;AACd,WAAK,KAAK,WAAW,WAAW,IAAI,UAAU;IAC/C;AACD,SAAK,KAAK,iBAAiB,QAAQ,KAAI,CAAE;AAEzC,UAAM,CAAC,IAAI,OAAK,KAAA,IAAI,SAAK,QAAA,OAAA,SAAA,SAAA,GAAA,SAAQ,IAAI,MAAM,gBAAgB,MAAM,GAAG;AACpE,QAAI,IAAI,KAAK;AACX,WAAK,KAAK,SAAS,GAAG,QAAQ,IAAI,IAAI,QAAQ,IAAI,IAAI,UAAU,IAAI;IACrE,WAAU,IAAI,IAAI;AACjB,WAAK,KAAK,SAAS,IAAI;IACxB;AAED,QAAI,UAAU;AACZ,WAAK,KAAK,UAAU,IAAI,MAAO,KAAI,CAAE;IACtC;AACD,SAAK,KAAK,UAAU,IAAI,OAAO,IAAI;AAEnC,SAAK,KAAK,cAAc,SAAS,EAAG,iBAAiB,SAAS,CAAC,MAAK;AAClE,QAAE,gBAAe;IACnB,CAAC;AACD,SAAK,iBAAiB,SAAS,MAAK;AAClC,WAAK,MAAK;IACZ,CAAC;;EAGH,KAAK,UAAkB,MAAc,YAAY,OAAK;AACpD,UAAM,KAAK,KAAK,KAAK,cAAc,QAAQ;AAC3C,QAAI,CAAC,WAAW;AACd,SAAG,cAAc;IAClB,OAAM;AACL,UAAI,WAAW;AACf,UAAI;AACJ,aAAQ,QAAQ,OAAO,KAAK,IAAI,GAAI;AAClC,cAAM,EAAE,GAAG,MAAM,MAAK,IAAK;AAC3B,YAAI,SAAS,MAAM;AACjB,gBAAM,OAAO,KAAK,MAAM,UAAU,KAAK;AACvC,aAAG,YAAY,SAAS,eAAe,IAAI,CAAC;AAC5C,gBAAM,OAAO,SAAS,cAAc,GAAG;AACvC,eAAK,cAAc;AACnB,eAAK,YAAY;AACjB,eAAK,UAAU,MAAK;AAClB,kBAAM,4BAA4B,mBAAmB,IAAI,CAAC;UAC5D;AACA,aAAG,YAAY,IAAI;AACnB,sBAAY,KAAK,SAAS,KAAK;QAChC;MACF;IACF;;EAGH,QAAK;;AACH,KAAA,KAAA,KAAK,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,YAAY,IAAI;;AAEpC;AAEM,IAAM,YAAY;AACzB,IAAM,EAAE,eAAc,IAAK;AAC3B,IAAI,kBAAkB,CAAC,eAAe,IAAI,SAAS,GAAG;AACpD,iBAAe,OAAO,WAAW,YAAY;AAC9C;AC9KD,QAAQ,MAAM,sBAAsB;AAEpC,IAAM,gBAAgB,IAAI,IAAI,YAAY,GAAG;AAG7C,IAAM,aAAa;AACnB,IAAM,iBACJ,qBAAqB,SAAS,aAAa,WAAW,QAAQ;AAChE,IAAM,UAAU;AAChB,IAAM,aAAa,GAAG,oBAAoB,cAAc,YACtD,WAAW,cAAc,OACxB;AACH,IAAM,mBAAmB;AACzB,IAAM,OAAO,YAAY;AACzB,IAAM,gBAA0B,CAAA;AAEhC,IAAI;AACJ,IAAI;AACF,MAAI;AAEJ,MAAI,CAAC,SAAS;AACZ,eAAW,MAAK;AAGd,eAAS,eAAe,gBAAgB,kBAAkB,MAAK;AAC7D,cAAM,uBAAuB,IAAI,IAAI,YAAY,GAAG;AACpD,cAAM,oBACJ,qBAAqB,OACrB,qBAAqB,SAAS,QAAQ,kBAAkB,EAAE;AAC5D,gBAAQ,MACN;;cAEiB,kCAAkC;cAClC,0CAA0C;2GACmD;MAElH,CAAC;AACD,aAAO,iBACL,QACA,MAAK;AACH,gBAAQ,KACN,0JAA0J;MAE9J,GACA,EAAE,MAAM,KAAI,CAAE;IAElB;EACD;AAED,WAAS,eAAe,gBAAgB,YAAY,QAAQ;AAC7D,SAAQ,OAAP;AACA,UAAQ,MAAM,0CAA0C,UAAU;AACnE;AAED,SAAS,eACP,UACA,aACA,oBAA+B;AAE/B,QAAMA,UAAS,IAAI,UAAU,GAAG,cAAc,eAAe,UAAU;AACvE,MAAI,WAAW;AAEf,EAAAA,QAAO,iBACL,QACA,MAAK;AACH,eAAW;EACb,GACA,EAAE,MAAM,KAAI,CAAE;AAIhB,EAAAA,QAAO,iBAAiB,WAAW,OAAO,EAAE,KAAI,MAAM;AACpD,kBAAc,KAAK,MAAM,IAAI,CAAC;EAChC,CAAC;AAGD,EAAAA,QAAO,iBAAiB,SAAS,OAAO,EAAE,SAAQ,MAAM;AACtD,QAAI;AAAU;AAEd,QAAI,CAAC,YAAY,oBAAoB;AACnC,yBAAkB;AAClB;IACD;AAED,YAAQ,IAAI,uDAAuD;AACnE,UAAM,sBAAsB,WAAW;AACvC,aAAS,OAAM;EACjB,CAAC;AAED,SAAOA;AACT;AAEA,SAAS,gBAAgB,KAAY,MAAuB;AAC1D,MAAI,CAAC,IAAI,QAAQ,MAAM,OAAO,GAAG;AAC/B,YAAQ,MAAM,GAAG;EAClB;AACD,UAAQ,MACN,0BAA0B,gGAEK;AAEnC;AAEA,SAAS,SAAS,UAAgB;AAChC,QAAM,MAAM,IAAI,IAAI,UAAU,SAAS,SAAQ,CAAE;AACjD,MAAI,aAAa,OAAO,QAAQ;AAChC,SAAO,IAAI,WAAW,IAAI;AAC5B;AAEA,IAAI,gBAAgB;AAEpB,eAAe,cAAc,SAAmB;AAC9C,UAAQ,QAAQ;SACT;AACH,cAAQ,MAAM,mBAAmB;AACjC,wBAAiB;AAGjB,kBAAY,MAAK;AACf,YAAI,OAAO,eAAe,OAAO,MAAM;AACrC,iBAAO,KAAK,iBAAiB;QAC9B;SACA,eAAe;AAClB;SACG;AACH,sBAAgB,qBAAqB,OAAO;AAK5C,UAAI,iBAAiB,gBAAe,GAAI;AACtC,eAAO,SAAS,OAAM;AACtB;MACD,OAAM;AACL,0BAAiB;AACjB,wBAAgB;MACjB;AACD,cAAQ,QAAQ,QAAQ,CAAC,WAAU;AACjC,YAAI,OAAO,SAAS,aAAa;AAC/B,sBAAY,YAAY,MAAM,CAAC;QAChC,OAAM;AAGL,gBAAM,EAAE,MAAM,UAAS,IAAK;AAC5B,gBAAM,YAAY,SAAS,IAAI;AAI/B,gBAAM,KAAK,MAAM,KACf,SAAS,iBAAkC,MAAM,CAAC,EAClD,KAAK,CAAC,MAAM,SAAS,EAAE,IAAI,EAAE,SAAS,SAAS,CAAC;AAClD,cAAI,IAAI;AACN,kBAAM,UAAU,GAAG,OAAO,UAAU,MAAM,CAAC,IACzC,UAAU,SAAS,GAAG,IAAI,MAAM,QAC7B;AAOL,kBAAM,aAAa,GAAG,UAAS;AAC/B,uBAAW,OAAO,IAAI,IAAI,SAAS,GAAG,IAAI,EAAE;AAC5C,kBAAM,cAAc,MAAM,GAAG,OAAM;AACnC,uBAAW,iBAAiB,QAAQ,WAAW;AAC/C,uBAAW,iBAAiB,SAAS,WAAW;AAChD,eAAG,MAAM,UAAU;UACpB;AACD,kBAAQ,IAAI,2BAA2B,WAAW;QACnD;MACH,CAAC;AACD;SACG,UAAU;AACb,sBAAgB,QAAQ,OAAO,QAAQ,IAAI;AAC3C;IACD;SACI;AACH,sBAAgB,yBAAyB,OAAO;AAChD,UAAI,QAAQ,QAAQ,QAAQ,KAAK,SAAS,OAAO,GAAG;AAGlD,cAAM,WAAW,UAAU,SAAS,QAAQ;AAC5C,cAAM,cAAc,OAAO,QAAQ,KAAK,MAAM,CAAC;AAC/C,YACE,aAAa,eACb,QAAQ,SAAS,iBAChB,SAAS,SAAS,GAAG,KAAK,WAAW,iBAAiB,aACvD;AACA,mBAAS,OAAM;QAChB;AACD;MACD,OAAM;AACL,iBAAS,OAAM;MAChB;AACD;SACG;AACH,sBAAgB,oBAAoB,OAAO;AAK3C,cAAQ,MAAM,QAAQ,CAAC,SAAQ;AAC7B,cAAM,KAAK,SAAS,IAAI,IAAI;AAC5B,YAAI,IAAI;AACN,aAAG,QAAQ,IAAI,IAAI,CAAC;QACrB;MACH,CAAC;AACD;SACG,SAAS;AACZ,sBAAgB,cAAc,OAAO;AACrC,YAAM,MAAM,QAAQ;AACpB,UAAI,eAAe;AACjB,2BAAmB,GAAG;MACvB,OAAM;AACL,gBAAQ,MACN;EAAiC,IAAI;EAAY,IAAI,OAAO;MAE/D;AACD;IACD;aACQ;AACP,YAAM,QAAe;AACrB,aAAO;IACR;;AAEL;AAMA,SAAS,gBAAgB,OAAe,MAAS;AAC/C,QAAM,MAAM,mBAAmB,IAAI,KAAK;AACxC,MAAI,KAAK;AACP,QAAI,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;EAC7B;AACH;AAEA,IAAM,gBAAgB;AAEtB,SAAS,mBAAmB,KAAwB;AAClD,MAAI,CAAC;AAAe;AACpB,oBAAiB;AACjB,WAAS,KAAK,YAAY,IAAI,aAAa,GAAG,CAAC;AACjD;AAEA,SAAS,oBAAiB;AACxB,WACG,iBAAiB,SAAS,EAC1B,QAAQ,CAAC,MAAO,EAAmB,MAAK,CAAE;AAC/C;AAEA,SAAS,kBAAe;AACtB,SAAO,SAAS,iBAAiB,SAAS,EAAE;AAC9C;AAEA,IAAI,UAAU;AACd,IAAI,SAA8C,CAAA;AAOlD,eAAe,YAAY,GAAoC;AAC7D,SAAO,KAAK,CAAC;AACb,MAAI,CAAC,SAAS;AACZ,cAAU;AACV,UAAM,QAAQ,QAAO;AACrB,cAAU;AACV,UAAM,UAAU,CAAC,GAAG,MAAM;AAC1B,aAAS,CAAA;AACR,KAAC,MAAM,QAAQ,IAAI,OAAO,GAAG,QAAQ,CAAC,OAAO,MAAM,GAAE,CAAE;EACzD;AACH;AAEA,eAAe,sBAAsB,aAAqB,KAAK,KAAI;AAEjE,SAAO,MAAM;AACX,QAAI;AAIF,YAAM,MAAM,GAAG,SAAS,aAAa,eAAe,EAAE,MAAM,UAAS,CAAE;AACvE;IACD,SAAQ,GAAP;AAEA,YAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;IACvD;EACF;AACH;AAaA,IAAM,YAAY,oBAAI,IAAG;AAKT,SAAA,YAAY,IAAY,SAAe;AACrD,MAAI,QAAQ,UAAU,IAAI,EAAE;AAiBrB;AACL,QAAI,SAAS,EAAE,iBAAiB,mBAAmB;AACjD,kBAAY,EAAE;AACd,cAAQ;IACT;AAED,QAAI,CAAC,OAAO;AACV,cAAQ,SAAS,cAAc,OAAO;AACtC,YAAM,aAAa,QAAQ,UAAU;AACrC,YAAM,YAAY;AAClB,eAAS,KAAK,YAAY,KAAK;IAChC,OAAM;AACL,YAAM,YAAY;IACnB;EACF;AACD,YAAU,IAAI,IAAI,KAAK;AACzB;AAEM,SAAU,YAAY,IAAU;AACpC,QAAM,QAAQ,UAAU,IAAI,EAAE;AAC9B,MAAI,OAAO;AACT,QAAI,iBAAiB,eAAe;AAElC,eAAS,qBAAqB,SAAS,mBAAmB,OACxD,CAAC,MAAqB,MAAM,KAAK;IAEpC,OAAM;AACL,eAAS,KAAK,YAAY,KAAK;IAChC;AACD,cAAU,OAAO,EAAE;EACpB;AACH;AAEA,eAAe,YAAY,EAAE,MAAM,cAAc,UAAS,GAAU;AAClE,QAAM,MAAM,cAAc,IAAI,IAAI;AAClC,MAAI,CAAC,KAAK;AAIR;EACD;AAED,QAAM,YAAY,oBAAI,IAAG;AACzB,QAAM,eAAe,SAAS;AAG9B,QAAM,kBAAkB,oBAAI,IAAG;AAC/B,MAAI,cAAc;AAEhB,oBAAgB,IAAI,IAAI;EACzB,OAAM;AAEL,eAAW,EAAE,KAAI,KAAM,IAAI,WAAW;AACpC,WAAK,QAAQ,CAAC,QAAO;AACnB,YAAI,iBAAiB,KAAK;AACxB,0BAAgB,IAAI,GAAG;QACxB;MACH,CAAC;IACF;EACF;AAGD,QAAM,qBAAqB,IAAI,UAAU,OAAO,CAAC,EAAE,KAAI,MAAM;AAC3D,WAAO,KAAK,KAAK,CAAC,QAAQ,gBAAgB,IAAI,GAAG,CAAC;EACpD,CAAC;AAED,QAAM,QAAQ,IACZ,MAAM,KAAK,eAAe,EAAE,IAAI,OAAO,QAAO;AAC5C,UAAM,WAAW,WAAW,IAAI,GAAG;AACnC,QAAI;AAAU,YAAM,SAAS,QAAQ,IAAI,GAAG,CAAC;AAC7C,UAAM,CAACC,OAAM,KAAK,IAAI,IAAI,MAAM,GAAG;AACnC,QAAI;AACF,YAAM,SAA0B,MAAM;;QAEpC,OACEA,MAAK,MAAM,CAAC,IACZ,aAAa,YAAY,QAAQ,IAAI,UAAU;;AAEnD,gBAAU,IAAI,KAAK,MAAM;IAC1B,SAAQ,GAAP;AACA,sBAAgB,GAAG,GAAG;IACvB;GACF,CAAC;AAGJ,SAAO,MAAK;AACV,eAAW,EAAE,MAAM,GAAE,KAAM,oBAAoB;AAC7C,SAAG,KAAK,IAAI,CAAC,QAAQ,UAAU,IAAI,GAAG,CAAC,CAAC;IACzC;AACD,UAAM,aAAa,eAAe,OAAO,GAAG,oBAAoB;AAChE,YAAQ,IAAI,uBAAuB,YAAY;EACjD;AACF;AAEA,SAAS,oBAAiB;AACxB,MAAI,OAAO,eAAe,GAAG;AAC3B,kBAAc,QAAQ,CAAC,QAAQ,OAAO,KAAK,GAAG,CAAC;AAC/C,kBAAc,SAAS;EACxB;AACH;AAeA,IAAM,gBAAgB,oBAAI,IAAG;AAC7B,IAAM,aAAa,oBAAI,IAAG;AAC1B,IAAM,WAAW,oBAAI,IAAG;AACxB,IAAM,UAAU,oBAAI,IAAG;AACvB,IAAM,qBAAyC,oBAAI,IAAG;AACtD,IAAM,oBAAoB,oBAAI,IAAG;AAE3B,SAAU,iBAAiB,WAAiB;AAChD,MAAI,CAAC,QAAQ,IAAI,SAAS,GAAG;AAC3B,YAAQ,IAAI,WAAW,CAAA,CAAE;EAC1B;AAID,QAAM,MAAM,cAAc,IAAI,SAAS;AACvC,MAAI,KAAK;AACP,QAAI,YAAY,CAAA;EACjB;AAGD,QAAM,iBAAiB,kBAAkB,IAAI,SAAS;AACtD,MAAI,gBAAgB;AAClB,eAAW,CAAC,OAAO,QAAQ,KAAK,gBAAgB;AAC9C,YAAM,YAAY,mBAAmB,IAAI,KAAK;AAC9C,UAAI,WAAW;AACb,2BAAmB,IACjB,OACA,UAAU,OAAO,CAAC,MAAM,CAAC,SAAS,SAAS,CAAC,CAAC,CAAC;MAEjD;IACF;EACF;AAED,QAAM,eAAmC,oBAAI,IAAG;AAChD,oBAAkB,IAAI,WAAW,YAAY;AAE7C,WAAS,WAAW,MAAgB,WAA8B,MAAA;EAAA,GAAQ;AACxE,UAAMC,OAAiB,cAAc,IAAI,SAAS,KAAK;MACrD,IAAI;MACJ,WAAW,CAAA;;AAEb,IAAAA,KAAI,UAAU,KAAK;MACjB;MACA,IAAI;IACL,CAAA;AACD,kBAAc,IAAI,WAAWA,IAAG;;AAGlC,QAAM,MAAsB;IAC1B,IAAI,OAAI;AACN,aAAO,QAAQ,IAAI,SAAS;;IAG9B,OAAO,MAAY,UAAc;AAC/B,UAAI,OAAO,SAAS,cAAc,CAAC,MAAM;AAEvC,mBAAW,CAAC,SAAS,GAAG,CAAC,CAACA,IAAG,MAAM,QAAQ,KAAKA,IAAG,CAAC;MACrD,WAAU,OAAO,SAAS,UAAU;AAEnC,mBAAW,CAAC,IAAI,GAAG,CAAC,CAACA,IAAG,MAAM,YAAY,SAASA,IAAG,CAAC;MACxD,WAAU,MAAM,QAAQ,IAAI,GAAG;AAC9B,mBAAW,MAAM,QAAQ;MAC1B,OAAM;AACL,cAAM,IAAI,MAAM,6BAA6B;MAC9C;;IAKH,cAAc,GAA+B,UAAc;AACzD,iBAAW,CAAC,SAAS,GAAG,aAAa,CAAC,CAACA,IAAG,MAAM,SAASA,IAAG,EAAE;;IAGhE,QAAQ,IAAE;AACR,iBAAW,IAAI,WAAW,EAAE;;IAI9B,MAAM,IAAuB;AAC3B,eAAS,IAAI,WAAW,EAAE;;IAK5B,UAAO;IAAA;IAEP,aAAU;AAGR,eAAS,OAAM;;IAIjB,GAAG,OAAO,IAAE;AACV,YAAM,WAAW,CAAC,QAA2B;AAC3C,cAAM,WAAW,IAAI,IAAI,KAAK,KAAK,CAAA;AACnC,iBAAS,KAAK,EAAE;AAChB,YAAI,IAAI,OAAO,QAAQ;MACzB;AACA,eAAS,kBAAkB;AAC3B,eAAS,YAAY;;IAGvB,KAAK,OAAO,MAAI;AACd,oBAAc,KAAK,KAAK,UAAU,EAAE,MAAM,UAAU,OAAO,KAAI,CAAE,CAAC;AAClE,wBAAiB;;;AAIrB,SAAO;AACT;AAKgB,SAAA,YAAY,KAAa,eAAqB;AAE5D,MAAI,CAAC,IAAI,WAAW,GAAG,KAAK,CAAC,IAAI,WAAW,GAAG,GAAG;AAChD,WAAO;EACR;AAGD,QAAM,WAAW,IAAI,QAAQ,QAAQ,EAAE,EAAE,QAAQ,SAAS,EAAE;AAC5D,QAAM,EAAE,QAAQ,KAAI,IAAK,IAAI,IAAI,KAAK,mBAAmB;AAEzD,SAAO,GAAG,YAAY,gBAAgB,SAAS,MAAM,OAAO,MAAM,CAAC,IAAI,KACrE,QAAQ;AAEZ;",
  "names": ["socket", "path", "mod"]
}
